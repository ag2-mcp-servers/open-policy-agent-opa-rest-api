# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T07:58:39+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel, confloat, constr


class Key(BaseModel):
    type: Optional[str] = None
    value: Optional[str] = None


class Value(BaseModel):
    type: Optional[str] = None
    value: Optional[str] = None


class Local(BaseModel):
    key: Optional[Key] = None
    value: Optional[Value] = None


class Term(BaseModel):
    type: Optional[str] = Field(None, examples=['var'])
    value: Optional[str] = Field(None, examples=['$term1'])


class Node(BaseModel):
    index: Optional[float] = Field(None, description='Node number')
    terms: Optional[List[Term]] = None


class Op(Enum):
    enter = 'enter'
    exit = 'exit'
    eval = 'eval'
    fail = 'fail'
    redo = 'redo'


class Type(Enum):
    expr = 'expr'
    rule = 'rule'
    body = 'body'


class ExplanationItem(BaseModel):
    locals: Optional[List[Local]] = Field(
        None,
        description="The query's term bindings at the point when the trace event was emitted.",
    )
    node: Optional[Node] = Field(
        None, description='The AST element associated with the evaluation step.'
    )
    op: Optional[Op] = Field(
        None,
        description='The kind of *trace event*\n\nEach trace event represents a step in the query evaluation process. Trace events are emitted at the following points:\n- enter - before a body or rule is evaluated\n- exit - after a body or rule has evaluated successfully\n- eval - before an expression is evaluated\n- fail - after an expression has evaluated to false.\n- redo - before evaluation restarts from a body, rule, or expression.\n\nBy default, OPA searches for all sets of term bindings that make all expressions in the query evaluate to true. Because there may be multiple answers, the search can restart when OPA determines the query is true or false. When the search restarts, a *redo trace event* is emitted.',
        examples=['enter'],
    )
    parent_id: Optional[confloat(ge=0.0)] = Field(
        None,
        description='The parent query. Use this field to identify trace events from related queries.\n\nFor example, if query A references rule R, trace events emitted when evaluating rule R will have the *parent_id* field set to query Aâ€™s *query_id*.',
        examples=[0],
    )
    query_id: Optional[confloat(ge=0.0)] = Field(
        None,
        description='The query that the trace event was emitted for. Use this field to distinguish trace events emitted by from different queries.',
        examples=[0],
    )
    type: Optional[Type] = Field(
        None, description='The type of the **node** field', examples=['expr']
    )


class Field200Explanations(BaseModel):
    explanation: Optional[List[ExplanationItem]] = None


class Metrics(BaseModel):
    counter_server_query_cache_hit: Optional[float] = Field(
        None, description='*Description is forthcoming*', examples=[0]
    )
    timer_query_compile_stage_build_comprehension_index_ns: Optional[float] = Field(
        None,
        description='(Only returned if `instrument` is true.) *Description is forthcoming*',
        examples=[43000],
    )
    timer_query_compile_stage_check_safety_ns: Optional[float] = Field(
        None,
        description='(Only returned if `instrument` is true.) *Description is forthcoming*',
        examples=[852000],
    )
    timer_query_compile_stage_check_types_ns: Optional[float] = Field(
        None,
        description='(Only returned if `instrument` is true.) *Description is forthcoming*',
        examples=[577000],
    )
    timer_query_compile_stage_check_undefined_funcs_ns: Optional[float] = Field(
        None,
        description='(Only returned if `instrument` is true.) *Description is forthcoming*',
        examples=[426000],
    )
    timer_query_compile_stage_check_unsafe_builtins_ns: Optional[float] = Field(
        None,
        description='(Only returned if `instrument` is true.) *Description is forthcoming*',
        examples=[14000],
    )
    timer_query_compile_stage_resolve_refs_ns: Optional[float] = Field(
        None,
        description='(Only returned if `instrument` is true.) *Description is forthcoming*',
        examples=[3000],
    )
    timer_query_compile_stage_rewrite_comprehension_terms_ns: Optional[float] = Field(
        None,
        description='(Only returned if `instrument` is true.) *Description is forthcoming*',
        examples=[329000],
    )
    timer_query_compile_stage_rewrite_dynamic_terms_ns: Optional[float] = Field(
        None,
        description='(Only returned if `instrument` is true.) *Description is forthcoming*',
        examples=[27000],
    )
    timer_query_compile_stage_rewrite_expr_terms_ns: Optional[float] = Field(
        None,
        description='(Only returned if `instrument` is true.) *Description is forthcoming*',
        examples=[40000],
    )
    timer_query_compile_stage_rewrite_local_vars_ns: Optional[float] = Field(
        None,
        description='(Only returned if `instrument` is true.) *Description is forthcoming*',
        examples=[187000],
    )
    timer_query_compile_stage_rewrite_to_capture_value_ns: Optional[float] = Field(
        None,
        description='(Only returned if `instrument` is true.) *Description is forthcoming*',
        examples=[1178000],
    )
    timer_query_compile_stage_rewrite_with_values_ns: Optional[float] = Field(
        None,
        description='(Only returned if `instrument` is true.) *Description is forthcoming*',
        examples=[23000],
    )
    timer_rego_input_parse_ns: Optional[float] = Field(
        None,
        description='Time taken (in nanonseconds) to parse the input',
        examples=[69994],
    )
    timer_rego_module_compile_ns: Optional[float] = Field(
        None,
        description='Time taken (in nanonseconds) to compile the loaded policy modules',
        examples=[69994],
    )
    timer_rego_module_parse_ns: Optional[float] = Field(
        None,
        description='Time taken (in nanoseconds) to parse the input policy module',
        examples=[12345],
    )
    timer_rego_query_compile_ns: Optional[float] = Field(
        None,
        description='Time taken (in nanoseconds) to compile the query',
        examples=[4096],
    )
    timer_rego_query_eval_ns: Optional[float] = Field(
        None,
        description='Time taken (in nanonseconds) to evaluate the query',
        examples=[69994],
    )
    timer_rego_query_parse_ns: Optional[float] = Field(
        None,
        description='Time taken (in nanoseconds) to parse the query',
        examples=[4096],
    )
    timer_server_handler_ns: Optional[float] = Field(
        None,
        description='Time taken (in nanoseconds) to handle the API request',
        examples=[631000],
    )
    timer_server_read_bytes_ns: Optional[float] = Field(
        None, description='*Description is forthcoming*', examples=[631000]
    )


class Field200Metrics(BaseModel):
    metrics: Optional[Metrics] = None


class Provenance(BaseModel):
    build_commit: Optional[str] = Field(
        None, description='The Git commit id of this OPA build.', examples=['4c6e524']
    )
    build_hostname: Optional[str] = Field(
        None,
        description='The hostname where this instance was built.',
        examples=['3bb58334a5a9'],
    )
    build_timestamp: Optional[str] = Field(
        None,
        description='When this OPA instance was built (in [ISO8601 format](https://www.w3.org/TR/NOTE-datetime))',
    )
    bundles: Optional[Dict[str, Any]] = Field(
        None,
        description='A set of key-value pairs describing each bundle activated on the server.',
    )
    version: Optional[str] = Field(None, description='The version of this OPA instance')


class Field200Provenance(BaseModel):
    provenance: Optional[Provenance] = None


class Type1(Enum):
    import_ = 'import'
    package = 'package'


class PathItem(BaseModel):
    type: Optional[Type1] = Field(
        None, description='The type of the path operation', examples=['import']
    )
    value: Optional[str] = Field(
        None, description='The path variable', examples=['data.opa.example']
    )


class Package(BaseModel):
    path: Optional[List[PathItem]] = Field(None, description='The path to the package')


class ValueItem(BaseModel):
    type: Optional[str] = None
    value: Optional[str] = None


class Term1(BaseModel):
    type: Optional[str] = Field(
        None, description='The type of the term variable', examples=['var']
    )
    value: Optional[List[ValueItem]] = Field(
        None, description='The list of types and values for the term variable'
    )


class BodyItem(BaseModel):
    index: Optional[float] = Field(
        None,
        description='The location of this term in the list (starts at 0)',
        examples=[1],
    )
    terms: Optional[List[Term1]] = Field(
        None, description='The type/value pairing for this term'
    )


class Key1(BaseModel):
    type: Optional[str] = Field(
        None, description='The type of the head', examples=['var']
    )
    value: Optional[str] = Field(
        None, description='The value of the head', examples=['$0']
    )


class Head(BaseModel):
    key: Optional[Key1] = Field(
        None, description="The type/value pairing for this rule's head"
    )
    name: Optional[str] = Field(
        None, description='The head of the rule', examples=['violations']
    )


class Rule(BaseModel):
    body: Optional[List[BodyItem]] = Field(
        None, description='A list of the terms in this rule'
    )
    head: Optional[Head] = None


class Ast(BaseModel):
    package: Optional[Package] = None
    rules: Optional[List[Rule]] = Field(
        None,
        description='When OPA evaluates a rule, it generates the content of a [virtual documents](https://www.openpolicyagent.org/docs/latest/philosophy/#the-opa-document-model)',
    )


class ResultItem(BaseModel):
    ast: Optional[Ast] = Field(
        None,
        description='The types for declarations and runtime objects passed to your implementation. This consists of an abstract syntax tree (AST) of policy modules, package and import declarations, rules, expressions, and terms.',
    )
    id: Optional[constr(min_length=1)] = Field(
        None, description='The name of a policy module', examples=['example2']
    )
    raw: Optional[constr(min_length=1)] = Field(
        None,
        description='A string representation of the full Rego policy',
        examples=[
            'package opa.examples\\n\\nimport data.servers\\n\\nviolations[server] {\\n\\tserver = servers[_]\\n\\tserver.protocols[_] = \\"http\\"\\n\\tpublic_servers[server]\\n}\\n'
        ],
    )


class Field200Result(BaseModel):
    result: Optional[List[ResultItem]] = None


class Authz(BaseModel):
    service: Optional[constr(min_length=1)] = Field(
        None, description='Service', examples=['acmecorp']
    )


class Bundles(BaseModel):
    authz: Optional[Authz] = Field(None, description='Auth')


class DecisionLogs(BaseModel):
    service: Optional[constr(min_length=1)] = Field(
        None, description='Service', examples=['acmecorp']
    )


class GlobalKey(BaseModel):
    scope: Optional[constr(min_length=1)] = Field(
        None, description='Scope', examples=['read']
    )


class Keys(BaseModel):
    global_key: Optional[GlobalKey] = Field(
        None, alias='global-key', description='Global Key'
    )


class Labels(BaseModel):
    id: Optional[constr(min_length=1)] = Field(
        None, description='Label ID', examples=['test-id']
    )
    version: Optional[constr(min_length=1)] = Field(
        None, description='Version', examples=['0.27.0']
    )


class Acmecorp(BaseModel):
    url: Optional[str] = Field(
        None, examples=['https://example.com/control-plane-api/v1']
    )


class Services(BaseModel):
    acmecorp: Optional[Acmecorp] = None


class Status(BaseModel):
    service: Optional[constr(min_length=1)] = Field(
        None, description='Service', examples=['acmecorp']
    )


class Result(BaseModel):
    bundles: Optional[Bundles] = Field(None, description='Bundles')
    decision_logs: Optional[DecisionLogs] = Field(None, description='Logs')
    default_authorization_decision: Optional[str] = Field(
        None, examples=['/system/authz/allow']
    )
    default_decision: Optional[str] = Field(None, examples=['/system/main'])
    keys: Optional[Keys] = Field(None, description='Keys')
    labels: Optional[Labels] = Field(None, description='Labels')
    services: Optional[Services] = Field(None, description='The types of services')
    status: Optional[Status] = Field(None, description='Status')


class Field200SingleResult(BaseModel):
    result: Optional[Result] = None


class Location(BaseModel):
    col: Optional[float] = Field(
        None,
        description='The column in the policy module where the error occurred',
        examples=[1],
    )
    file: Optional[str] = Field(
        None,
        description='The policy module name that generated the error',
        examples=['example1'],
    )
    row: Optional[float] = Field(
        None,
        description='The line number in the policy module where the error occurred',
        examples=[3],
    )


class Error(BaseModel):
    code: Optional[constr(min_length=1)] = Field(
        None, description='The error code name', examples=['rego_unsafe_var_error']
    )
    location: Optional[Location] = Field(None, description='Where the error occurred')
    message: Optional[constr(min_length=1)] = Field(
        None,
        description='A general description of the error',
        examples=['var x is unsafe'],
    )


class Field400(BaseModel):
    code: constr(min_length=1) = Field(
        ..., description='The error code name', examples=['invalid_parameter']
    )
    errors: Optional[List[Error]] = Field(
        None,
        description='Errors that may have been generated during the parse, compile, or installation of a policy module',
    )
    message: constr(min_length=1) = Field(
        ...,
        description='The description of the error',
        examples=['error(s) occurred while compiling module(s)'],
    )


class Field404(BaseModel):
    code: constr(min_length=1) = Field(
        ..., description='The error code name', examples=['resource_not_found']
    )
    message: constr(min_length=1) = Field(
        ...,
        description='The description of the error (including the name of any undefined policy module)',
        examples=['storage_not_found_error: policy id \\"partial\\"'],
    )


class DataSchema(RootModel[Any]):
    root: Any = Field(
        ...,
        examples=[
            '{\n  "users": {\n    "user-id-1": {\n      "isAdmin": true\n    }\n  }\n}'
        ],
    )


class InputSchema(RootModel[Optional[Dict[str, Any]]]):
    root: Optional[Dict[str, Any]] = None


class PartialQuerySchema(RootModel[Optional[Dict[str, Any]]]):
    root: Optional[Dict[str, Any]] = None


class Op1(Enum):
    add = 'add'
    remove = 'remove'
    replace = 'replace'
    move = 'move'
    copy = 'copy'
    test = 'test'


class PatchesSchemaItem(BaseModel):
    op: Op1 = Field(..., description='JSON patch operation type', examples=['add'])
    path: constr(min_length=1) = Field(
        ...,
        description="A [JSON pointer](https://tools.ietf.org/html/rfc6901) to a location within the target document where the operation is performed.\n\nThe *effective path* is this value prefixed with the API call's `path` parameter.\n\nThe server will return a *bad request* (404) response if:\n\n- The *parent* of the effective path does not refer to an existing document\n- For **remove** and **replace** operations, the effective path does not refer to an existing document.",
        examples=['-'],
    )
    value: Optional[Dict[str, Any]] = Field(
        None,
        description='The value to add, replace or test.',
        examples=[
            '{\n  "id": "s5",\n  "name": "job",\n  "protocols": ["amqp"],\n  "ports": ["p3"]\n}'
        ],
    )


class PatchesSchema(RootModel[List[PatchesSchemaItem]]):
    root: List[PatchesSchemaItem] = Field(
        ...,
        description='A list of one or more [JSON patch operations](http://jsonpatch.com/)',
        min_length=1,
    )


class QSchema(RootModel[Optional[Dict[str, Any]]]):
    root: Optional[Dict[str, Any]] = None


class QueryInputSchema(RootModel[Optional[Dict[str, Any]]]):
    root: Optional[Dict[str, Any]] = None


class WebhookInputSchema(RootModel[Optional[Dict[str, Any]]]):
    root: Optional[Dict[str, Any]] = None


class V0DataPathPostResponse(
    Field200Result, Field200Provenance, Field200Metrics, Field200Explanations
):
    pass


class V1CompilePostResponse(Field200Result, Field200Metrics, Field200Explanations):
    pass


class V1DataPathGetResponse(
    Field200Result, Field200Provenance, Field200Metrics, Field200Explanations
):
    pass


class Input(RootModel[Optional[Dict[str, Any]]]):
    root: Optional[Dict[str, Any]] = None


class V1DataPathPostResponse(
    Field200Result, Field200Provenance, Field200Metrics, Field200Explanations
):
    pass


class V1PoliciesIdDeleteResponse(
    Field200Result, Field200Provenance, Field200Metrics, Field200Explanations
):
    pass


class V1QueryGetResponse(Field200Result, Field200Metrics, Field200Explanations):
    pass


class V1QueryPostResponse(Field200Result, Field200Metrics, Field200Explanations):
    pass
